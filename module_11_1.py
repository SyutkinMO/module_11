# ----------Знакомство с сторонними библиотеками в Python------------


import requests

"""библиотека позволяет нам легко и с минимальным количеством кода взаимодействовать с веб-приложениями. 
Это необходимо нам для решения любых задач, связанных с передачей информации от пользователя к серверу и обратно."""

ya_ = requests.get('https://market.yandex.ru/')  # узнаем, работает ли сайт. Для этого мы создадим простой запрос GET
print(ya_)
""" в качестве ответа мы получили объект класса Response и код 200. Этот код говорит, что ресурс работает 
и можно с ним взаимодействовать."""
ya_ = requests.get('https://market.yandex.ru/user')  # отправляем неправильный запрос
print(ya_)
# print(ya_.raise_for_status()) - если необходимо поднять исключение
""" этот запрос вернул нам всё тот же объект класса Response, но с другим кодом - 404. 
Это означает, что страницы ‘/user’ на сайте https://market.yandex.ru нет"""

"""В этом примере мы будем применять всё тот же запрос GET, но, в отличие от предыдущего, 
мы будем работать с содержимым ответа."""
image = requests.get('https://images.wallpaperscraft.ru/image/single/kot_pitomets_pushistyj_1335865_1280x720.jpg')
with open('new_image.png', 'wb') as file:
    file.write(image.content)
"""После выполнения данного скрипта, мы увидим новое изображение под названием new_image.png в директории, 
из которой у нас запущен скрипт."""

import pandas as pd  # Библиотека Pandas разрабатывалась для работы с табличными данными.

data_ = pd.read_csv('data.csv')  # Чтение данных из файла
print(data_)  # вывод всей таблицы
print(data_.head(2))  # вывод первых двух строк
print(data_.tail(2))  # вывод последних двух строк

# Для чтения Excel файлов используют метод read_excel():
data_ex = pd.read_excel('data.xlsx')  # перед этим необходимо установить пакет openpyxl в виртуальное окружение
print(data_ex)  # по умолчанию выводятся первые 5 и последние 5 строк

# В read_excel() можно передать дополнительный параметр, чтобы вывести определенный лист по его названию или по индексу:
data_ex = pd.read_excel('data.xlsx', sheet_name='Лист1')  # по названию
print(data_ex)
data_ex = pd.read_excel('data.xlsx', sheet_name=0)  # по индексу
print(data_ex)

# можно пропустить нужное количество строк:
data_ex = pd.read_excel('data.xlsx', skiprows=5)  # пропускаем первые 5 строк

"""DataFrame – это двумерная табличная структура данных. Каждый столбец в таблице может содержать данные 
различного типа (числа, строки, булевы значения и т.д.)."""

data_frame = pd.DataFrame({'A': [6, 1, 9], 'B': [5, 7, 9]})
print(data_frame.sort_values(by='A'))  # сортируем данные по столбцу А

"""isnull() – возвращает True, если обнаруживает пропуск значения:"""
data_frame = pd.DataFrame({'Углеводы': [43, 27, None, 49],
                           'Жиры': [50, None, 17, 8],
                           'Белки': [25, 5, 11, None]})

# ищем пропущенные значения
missing_values = data_frame.isnull()
print(missing_values)

"""fillna() – заполняет пропущенные значения нужными показателями:"""

dataframe = pd.DataFrame({'Выручка': [105600, 209800, None, 403450],
                          'Убытки': [5034, None, 17093, 80666],
                          'Накладные расходы': [15000, None, 17000, 18000]})

# заполняем пропущенные значения нулями
filled_dataframe = dataframe.fillna(0)
print(filled_dataframe)

# merge() – объединяет DataFrame на основе общих столбцов:

dataframe1 = pd.DataFrame({'A': [10, 20, 30, 40],
                           'B': ['XL', 'L', 'M', 'S']})

dataframe2 = pd.DataFrame({'A': [10, 20, 30, 40],
                           'C': ['52', '48', '46', '42']})

# объединяем 2 объекта DataFrame на основе столбца 'A'
merged_dataframe = pd.merge(dataframe1, dataframe2, on='A')
print(merged_dataframe)

import numpy as np

"""NumPy это open-source модуль для python, который предоставляет общие математические и числовые операции в виде 
пре-скомпилированных, быстрых функций. Они объединяются в высокоуровневые пакеты. Они обеспечивают функционал, 
который можно сравнить с функционалом MatLab. NumPy (Numeric Python) предоставляет базовые методы для манипуляции 
с большими массивами и матрицами. SciPy (Scientific Python) расширяет функционал numpy огромной коллекцией полезных 
алгоритмов, таких как минимизация, преобразование Фурье, регрессия, и другие прикладные математические техники."""

""""Массивы
Главной особенностью numpy является объект array. Массивы схожи со списками в python, исключая тот факт, 
что элементы массива должны иметь одинаковый тип данных, как float и int. С массивами можно проводить числовые операции 
с большим объемом информации в разы быстрее и, главное, намного эффективнее чем со списками."""

a = np.array([1, 4, 5, 8], float)
print(a)
print(type(a))  # <class 'numpy.ndarray'>

"""Здесь функция array принимает два аргумента: список для конвертации в массив и тип для каждого элемента. 
Ко всем элементам можно получить доступ и манипулировать ими так же, как вы бы это делали с обычными списками:"""

print(a[:2])  # array([ 1.,  4.])
print(a[3])  # 8.0
a[0] = 5.
print(a)  # array([ 5.,  4.,  5.,  8.])

"""Массивы могут быть и многомерными. В отличии от списков можно использовать запятые в скобках. 
Вот пример двумерного массива (матрица):"""

a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(a)
print(a[0, 0])  # первая цифра обращение к массиву по индексу, вторая к цифре массива по индексу
print(a[0, 1])

"""
Array slicing работает с многомерными массивами аналогично, как и с одномерными, применяя каждый срез, как фильтр 
для установленного измерения. Используйте ":" в измерении для указывания использования всех элементов этого измерения:
"""
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(a[1, :])  # array([ 4.,  5.,  6.])
print(a[:, 2])  # array([ 3.,  6.])
print(a[-1:, -2:])  # array([[ 5.,  6.]])

# Метод shape возвращает количество строк и столбцов в матрице:
print(a.shape)  # (2,3)

# Метод len возвращает длину первого измерения (оси):
print(len(a))  # 2

# Метод in используется для проверки на наличие элемента в массиве:
print(2 in a)  # True
print(0 in a)  # False

"""
Массивы можно переформировать при помощи метода, который задает новый многомерный массив. Следуя следующему примеру, 
мы переформатируем одномерный массив из десяти элементов во двумерный массив, состоящий из пяти строк и двух столбцов:
"""
a = np.array(range(10), float)
print(a)  # array([ 0.,  1.,  2., 3.,  4.,  5.,  6.,  7.,  8.,  9.])
a = a.reshape((5, 2))
print(a)  # array([[ 0.,  1.],[ 2.,  3.],[ 4.,  5.],[ 6.,  7.],[ 8.,  9.]])
print(a.shape)  # (5, 2)

# Списки тоже можно создавать с массивов

a = np.array([1, 2, 3], float)
print(a.tolist())  # [1.0, 2.0, 3.0]

# Заполнение массива одинаковым значением.
a = np.array([1, 2, 3], float)
print(a)  # array([ 1.,  2.,  3.])
a.fill(0)
print(a)  # array([ 0.,  0.,  0.])

# Транспонирование массивов также возможно, при этом создается новый массив:
a = np.array(range(6), float).reshape((2, 3))
print(a)  # array([[ 0.,  1.,  2.],[ 3.,  4.,  5.]])
print(a.transpose())  # array([[ 0.,  3.],[ 1.,  4.],[ 2.,  5.]])

# Многомерный массив можно переконвертировать в одномерный при помощи метода flatten:
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(a)  # array([[ 1.,  2.,  3.],[ 4.,  5.,  6.]])
print(a.flatten())  # array([ 1.,  2.,  3.,  4.,  5.,  6.])

# Два или больше массивов можно сконкатенировать при помощи метода concatenate:
a = np.array([1, 2], float)
b = np.array([3, 4, 5, 6], float)
c = np.array([7, 8, 9], float)
print(np.concatenate((a, b, c)))  # array([1., 2., 3., 4., 5., 6., 7., 8., 9.])

"""Если массив не одномерный, можно задать ось, по которой будет происходить соединение. 
По умолчанию (не задавая значения оси), соединение будет происходить по первому измерению"""

a = np.array([[1, 2], [3, 4]], float)
b = np.array([[5, 6], [7, 8]], float)
print(np.concatenate((a, b)))  # array([[ 1.,  2.],[ 3.,  4.],[ 5.,  6.],[ 7.,  8.]])
print(np.concatenate((a, b), axis=0))  # array([[ 1.,  2.],[ 3.,  4.],[ 5.,  6.],[ 7.,  8.]])
print(np.concatenate((a, b), axis=1))  # array([[ 1.,  2.,  5.,  6.],[ 3.,  4.,  7.,  8.]])

"""размерность массива может быть увеличена при использовании константы newaxis в квадратных скобках:"""

a = np.array([1, 2, 3], float)
print(a)  # array([1., 2., 3.])
print(a[:, np.newaxis])  # array([[ 1.],[ 2.],[ 3.]])
print(a[:, np.newaxis].shape)  # (3,1)
print(a[np.newaxis, :])  # array([[ 1.,  2.,  3.]])
print(a[np.newaxis, :].shape)  # (1,3)
